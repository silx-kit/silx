# coding: utf-8
# /*##########################################################################
#
# Copyright (c) 2004-2016 European Synchrotron Radiation Facility
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ###########################################################################*/
"""Functions to prepare events to be sent to Plot callback."""

__author__ = ["V.A. Sole", "T. Vincent"]
__license__ = "MIT"
__date__ = "13/04/2017"


import numpy as np
import enum
from silx.gui import qt


class Type(enum.Enum):
    """Event type used for `PlotEvent` class."""

    LimitChanged = 'limitsChanged'
    """Type of the `LimitsChangedEvent`"""

    MouseMoved = 'mouseMoved'
    """Type of the `MouseEvent` when mouse moving"""

    MouseClicked = 'mouseClicked'
    """Type of the `MouseEvent` when mouse is clicked"""

    MouseDoubleClicked = 'mouseDoubleClicked'
    """Type of the `MouseEvent` when mouse is double clicked"""


class PlotEvent(object):
    """The PlotEvent provides an abstract event that is generated by the plot
    module."""

    def __init__(self, eventType):
        """Constructor

        :param Type eventType: Type of the event.
        """
        self.__type = eventType

    def getType(self):
        """Returns the type of the event.

        :rtype: Type
        """
        return self.__type


def prepareDrawingSignal(event, type_, points, parameters=None):
    """See Plot documentation for content of events"""
    assert event in ('drawingProgress', 'drawingFinished')

    if parameters is None:
        parameters = {}

    eventDict = {}
    eventDict['event'] = event
    eventDict['type'] = type_
    points = np.array(points, dtype=np.float32)
    points.shape = -1, 2
    eventDict['points'] = points
    eventDict['xdata'] = points[:, 0]
    eventDict['ydata'] = points[:, 1]
    if type_ in ('rectangle',):
        eventDict['x'] = eventDict['xdata'].min()
        eventDict['y'] = eventDict['ydata'].min()
        eventDict['width'] = eventDict['xdata'].max() - eventDict['x']
        eventDict['height'] = eventDict['ydata'].max() - eventDict['y']
    eventDict['parameters'] = parameters.copy()
    return eventDict


class MouseEvent(PlotEvent):
    """The MouseEvent provides an event that is generated when the mouse is
    activated of the plot."""

    def __init__(self, eventType, button, scenePos, screenPos):
        """Constructor

        :param qt.Qt.MouseButton button: The clicked button if exists
        :param tuple(int,int) scenePos: Scene position of the mouse
        :param tuple(int,int) screenPos: Screen position (pixels relative to
            widget) of the mouse.
        """
        super(MouseEvent, self).__init__(eventType)
        self._button = button
        self._scenePos = scenePos
        self._screenPos = screenPos

    def getButton(self):
        """
        Returns the activated button in case of a MouseClicked event

        :rtype: qt.Qt.MouseButton
        """
        return self._button

    def getScenePos(self):
        """Returns the current scene position of the mouse (x, y).

        :rtype: tuple(float,float)
        """
        return self._scenePos

    def getScreenPos(self):
        """Return the current screen position (pixels relative to widget) of
        the mouse.

        :rtype: tuple(int,int)
        """
        return self._screenPos

    def __getitem__(self, key):
        """Returns event content using the old dictionary-key mapping.

        This is deprecated. Look at the source code to have a description of
        available key names.

        :param str key: Name of the old key.
        :rtype: object
        :raises KeyError: If the requested key is not available
        """
        if key == 'event':
            events = {
                Type.MouseMoved: 'mouseMoved',
                Type.MouseClicked: 'mouseClicked',
                Type.MouseDoubleClicked: 'mouseDoubleClicked',
            }
            return events[self.getType()]
        elif key == "x":
            return self.getScenePos()[0]
        elif key == "y":
            return self.getScenePos()[1]
        elif key == 'xpixel':
            return self.getScreenPos()[0]
        elif key == 'ypixel':
            return self.getScreenPos()[1]
        elif key == 'button':
            buttons = {
                'left': 'left',
                'right': 'right',
                'middle': 'middle',
                qt.Qt.LeftButton: 'left',
                qt.Qt.RightButton: 'right',
                qt.Qt.MiddleButton: 'middle',
                qt.Qt.NoButton: None,
            }
            return buttons[self.getButton()]
        else:
            raise KeyError("Key %s not found" % key)


class MouseMovedEvent(MouseEvent):
    """The MouseMovedEvent provides an event that is generated when the mouse
    is moved on the plot."""

    def __init__(self, scenePos, screenPos):
        """Constructor

        :param tuple(int,int) scenePos: Scene position of the mouse
        :param tuple(int,int) screenPos: Screen position (pixels relative to
            widget) of the mouse.
        """
        MouseEvent.__init__(self,
                            Type.MouseMoved,
                            qt.Qt.NoButton,
                            scenePos,
                            screenPos)


class MouseClickedEvent(MouseEvent):
    """The MouseClickedEvent provides an event that is generated when the mouse
    is clicked on the plot."""

    def __init__(self, button, scenePos, screenPos):
        """Constructor

        :param qt.Qt.MouseButton button: The clicked button if exists
        :param tuple(int,int) scenePos: Scene position of the mouse
        :param tuple(int,int) screenPos: Screen position (pixels relative to
            widget) of the mouse.
        """
        MouseEvent.__init__(self,
                            Type.MouseClicked,
                            button,
                            scenePos,
                            screenPos)


class MouseDoubleClickedEvent(MouseEvent):
    """The MouseDoubleClickedEvent provides an event that is generated when the
    mouse double clicked on the plot."""

    def __init__(self, button, scenePos, screenPos):
        """Constructor

        :param qt.Qt.MouseButton button: The clicked button if exists
        :param tuple(int,int) scenePos: Scene position of the mouse
        :param tuple(int,int) screenPos: Screen position (pixels relative to
            widget) of the mouse.
        """
        MouseEvent.__init__(self,
                            Type.MouseDoubleClicked,
                            button,
                            scenePos,
                            screenPos)


def prepareHoverSignal(label, type_, posData, posPixel, draggable, selectable):
    """See Plot documentation for content of events"""
    return {'event': 'hover',
            'label': label,
            'type': type_,
            'x': posData[0],
            'y': posData[1],
            'xpixel': posPixel[0],
            'ypixel': posPixel[1],
            'draggable': draggable,
            'selectable': selectable}


def prepareMarkerSignal(eventType, button, label, type_,
                        draggable, selectable,
                        posDataMarker,
                        posPixelCursor=None, posDataCursor=None):
    """See Plot documentation for content of events"""
    if eventType == 'markerClicked':
        assert posPixelCursor is not None
        assert posDataCursor is None

        posDataCursor = list(posDataMarker)
        if hasattr(posDataCursor[0], "__len__"):
            posDataCursor[0] = posDataCursor[0][-1]
        if hasattr(posDataCursor[1], "__len__"):
            posDataCursor[1] = posDataCursor[1][-1]

    elif eventType == 'markerMoving':
        assert posPixelCursor is not None
        assert posDataCursor is not None

    elif eventType == 'markerMoved':
        assert posPixelCursor is None
        assert posDataCursor is None

        posDataCursor = posDataMarker
    else:
        raise NotImplementedError("Unknown event type {0}".format(eventType))

    eventDict = {'event': eventType,
                 'button': button,
                 'label': label,
                 'type': type_,
                 'x': posDataCursor[0],
                 'y': posDataCursor[1],
                 'xdata': posDataMarker[0],
                 'ydata': posDataMarker[1],
                 'draggable': draggable,
                 'selectable': selectable}

    if eventType in ('markerMoving', 'markerClicked'):
        eventDict['xpixel'] = posPixelCursor[0]
        eventDict['ypixel'] = posPixelCursor[1]

    return eventDict


def prepareImageSignal(button, label, type_, col, row,
                       x, y, xPixel, yPixel):
    """See Plot documentation for content of events"""
    return {'event': 'imageClicked',
            'button': button,
            'label': label,
            'type': type_,
            'col': col,
            'row': row,
            'x': x,
            'y': y,
            'xpixel': xPixel,
            'ypixel': yPixel}


def prepareCurveSignal(button, label, type_, xData, yData,
                       x, y, xPixel, yPixel):
    """See Plot documentation for content of events"""
    return {'event': 'curveClicked',
            'button': button,
            'label': label,
            'type': type_,
            'xdata': xData,
            'ydata': yData,
            'x': x,
            'y': y,
            'xpixel': xPixel,
            'ypixel': yPixel}


class LimitsChangedEvent(PlotEvent):
    """The LimitsChangedEvent provides an event that is generated when the
    limits of the plot are changed."""

    def __init__(self, source, xRange, yRange, y2Range):
        """
        Constructor

        :param object source: Source of the event (only used for compatibility)
        :param tuple xRange: Range min,max of the x-axis
        :param tuple yRange: Range min,max of the y-axis
        :param tuple y2Range: Range min,max of the second y-axis
        """
        super(LimitsChangedEvent, self).__init__(Type.LimitChanged)
        self._xRange = xRange
        self._yRange = yRange
        self._y2Range = y2Range
        # stored for compatibility, but not anymore provided
        self._source = source

    def getXRange(self):
        """Returns a tuple min,max of the range of the current x-axis.

        :rtype: tuple(float, float)
        """
        return self._xRange

    def getYRange(self):
        """Returns a tuple min,max of the range of the current y-axis.

        :rtype: tuple(float, float)
        """
        return self._yRange

    def getY2Range(self):
        """Returns a tuple min,max of the range of the current second y-axis.

        :rtype: tuple(float, float)
        """
        return self._y2Range

    @classmethod
    def __getDictionaryMapping(cls):
        """Returns a cached mapping used to provide compatibility with the old
        dictionary events"""
        if hasattr(cls, "__mapping"):
            return cls._mapping
        mapping = {
            'event': lambda self: "limitsChanged",
            'source': lambda self: id(self._source),
            'xdata': lambda self: self.getXRange(),
            'ydata': lambda self: self.getYRange(),
            'y2data': lambda self: self.getY2Range(),
        }
        cls.__mapping = mapping
        return cls.__mapping

    def __getitem__(self, key):
        """Returns event content using the old dictionary-key mapping.

        This is deprecated. Look at the source code to have a description of
        available key names.

        :param str key: Name of the old key.
        :rtype: object
        :raises KeyError: If the requested key is not available
        """
        mapping = self.__getDictionaryMapping()
        return mapping[key](self)
